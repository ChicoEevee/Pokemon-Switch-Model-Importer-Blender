# automatically generated by the FlatBuffers compiler, do not modify

# namespace: Model

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class MeshShape(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MeshShape()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMeshShape(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # MeshShape
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # MeshShape
    def MeshShapeName(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # MeshShape
    def Bounds(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from Titan.Model.BoundingBox import BoundingBox
            obj = BoundingBox()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MeshShape
    def PolygonType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # MeshShape
    def Attributes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from Titan.Model.VertexAccessors import VertexAccessors
            obj = VertexAccessors()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MeshShape
    def AttributesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MeshShape
    def AttributesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # MeshShape
    def Materials(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from Titan.Model.MaterialInfo import MaterialInfo
            obj = MaterialInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MeshShape
    def MaterialsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MeshShape
    def MaterialsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # MeshShape
    def Res0(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # MeshShape
    def Res1(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # MeshShape
    def Res2(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # MeshShape
    def Res3(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # MeshShape
    def ClipSphere(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = o + self._tab.Pos
            from Titan.Model.Sphere import Sphere
            obj = Sphere()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MeshShape
    def Influence(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from Titan.Model.Influence import Influence
            obj = Influence()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MeshShape
    def InfluenceLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MeshShape
    def InfluenceIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return o == 0

    # MeshShape
    def VisShapes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from Titan.Model.VisShape import VisShape
            obj = VisShape()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MeshShape
    def VisShapesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MeshShape
    def VisShapesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

    # MeshShape
    def MeshName(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # MeshShape
    def Unk13(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # MeshShape
    def MorphShape(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from Titan.Model.MorphShape import MorphShape
            obj = MorphShape()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MeshShape
    def MorphShapeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MeshShape
    def MorphShapeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        return o == 0

def MeshShapeStart(builder):
    builder.StartObject(15)

def Start(builder):
    MeshShapeStart(builder)

def MeshShapeAddMeshShapeName(builder, meshShapeName):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(meshShapeName), 0)

def AddMeshShapeName(builder, meshShapeName):
    MeshShapeAddMeshShapeName(builder, meshShapeName)

def MeshShapeAddBounds(builder, bounds):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(bounds), 0)

def AddBounds(builder, bounds):
    MeshShapeAddBounds(builder, bounds)

def MeshShapeAddPolygonType(builder, polygonType):
    builder.PrependUint32Slot(2, polygonType, 0)

def AddPolygonType(builder, polygonType):
    MeshShapeAddPolygonType(builder, polygonType)

def MeshShapeAddAttributes(builder, attributes):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(attributes), 0)

def AddAttributes(builder, attributes):
    MeshShapeAddAttributes(builder, attributes)

def MeshShapeStartAttributesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartAttributesVector(builder, numElems):
    return MeshShapeStartAttributesVector(builder, numElems)

def MeshShapeAddMaterials(builder, materials):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(materials), 0)

def AddMaterials(builder, materials):
    MeshShapeAddMaterials(builder, materials)

def MeshShapeStartMaterialsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartMaterialsVector(builder, numElems):
    return MeshShapeStartMaterialsVector(builder, numElems)

def MeshShapeAddRes0(builder, res0):
    builder.PrependUint32Slot(5, res0, 0)

def AddRes0(builder, res0):
    MeshShapeAddRes0(builder, res0)

def MeshShapeAddRes1(builder, res1):
    builder.PrependUint32Slot(6, res1, 0)

def AddRes1(builder, res1):
    MeshShapeAddRes1(builder, res1)

def MeshShapeAddRes2(builder, res2):
    builder.PrependUint32Slot(7, res2, 0)

def AddRes2(builder, res2):
    MeshShapeAddRes2(builder, res2)

def MeshShapeAddRes3(builder, res3):
    builder.PrependUint32Slot(8, res3, 0)

def AddRes3(builder, res3):
    MeshShapeAddRes3(builder, res3)

def MeshShapeAddClipSphere(builder, clipSphere):
    builder.PrependStructSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(clipSphere), 0)

def AddClipSphere(builder, clipSphere):
    MeshShapeAddClipSphere(builder, clipSphere)

def MeshShapeAddInfluence(builder, influence):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(influence), 0)

def AddInfluence(builder, influence):
    MeshShapeAddInfluence(builder, influence)

def MeshShapeStartInfluenceVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartInfluenceVector(builder, numElems):
    return MeshShapeStartInfluenceVector(builder, numElems)

def MeshShapeAddVisShapes(builder, visShapes):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(visShapes), 0)

def AddVisShapes(builder, visShapes):
    MeshShapeAddVisShapes(builder, visShapes)

def MeshShapeStartVisShapesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartVisShapesVector(builder, numElems):
    return MeshShapeStartVisShapesVector(builder, numElems)

def MeshShapeAddMeshName(builder, meshName):
    builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(meshName), 0)

def AddMeshName(builder, meshName):
    MeshShapeAddMeshName(builder, meshName)

def MeshShapeAddUnk13(builder, unk13):
    builder.PrependUint32Slot(13, unk13, 0)

def AddUnk13(builder, unk13):
    MeshShapeAddUnk13(builder, unk13)

def MeshShapeAddMorphShape(builder, morphShape):
    builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(morphShape), 0)

def AddMorphShape(builder, morphShape):
    MeshShapeAddMorphShape(builder, morphShape)

def MeshShapeStartMorphShapeVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartMorphShapeVector(builder, numElems):
    return MeshShapeStartMorphShapeVector(builder, numElems)

def MeshShapeEnd(builder):
    return builder.EndObject()

def End(builder):
    return MeshShapeEnd(builder)

import Titan.Model.BoundingBox
import Titan.Model.Influence
import Titan.Model.MaterialInfo
import Titan.Model.MorphShape
import Titan.Model.Sphere
import Titan.Model.VertexAccessors
import Titan.Model.VisShape
try:
    from typing import List, Optional
except:
    pass

class MeshShapeT(object):

    # MeshShapeT
    def __init__(self):
        self.meshShapeName = None  # type: str
        self.bounds = None  # type: Optional[Titan.Model.BoundingBox.BoundingBoxT]
        self.polygonType = 0  # type: int
        self.attributes = None  # type: List[Titan.Model.VertexAccessors.VertexAccessorsT]
        self.materials = None  # type: List[Titan.Model.MaterialInfo.MaterialInfoT]
        self.res0 = 0  # type: int
        self.res1 = 0  # type: int
        self.res2 = 0  # type: int
        self.res3 = 0  # type: int
        self.clipSphere = None  # type: Optional[Titan.Model.Sphere.SphereT]
        self.influence = None  # type: List[Titan.Model.Influence.InfluenceT]
        self.visShapes = None  # type: List[Titan.Model.VisShape.VisShapeT]
        self.meshName = None  # type: str
        self.unk13 = 0  # type: int
        self.morphShape = None  # type: List[Titan.Model.MorphShape.MorphShapeT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        meshShape = MeshShape()
        meshShape.Init(buf, pos)
        return cls.InitFromObj(meshShape)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, meshShape):
        x = MeshShapeT()
        x._UnPack(meshShape)
        return x

    # MeshShapeT
    def _UnPack(self, meshShape):
        if meshShape is None:
            return
        self.meshShapeName = meshShape.MeshShapeName()
        if meshShape.Bounds() is not None:
            self.bounds = Titan.Model.BoundingBox.BoundingBoxT.InitFromObj(meshShape.Bounds())
        self.polygonType = meshShape.PolygonType()
        if not meshShape.AttributesIsNone():
            self.attributes = []
            for i in range(meshShape.AttributesLength()):
                if meshShape.Attributes(i) is None:
                    self.attributes.append(None)
                else:
                    vertexAccessors_ = Titan.Model.VertexAccessors.VertexAccessorsT.InitFromObj(meshShape.Attributes(i))
                    self.attributes.append(vertexAccessors_)
        if not meshShape.MaterialsIsNone():
            self.materials = []
            for i in range(meshShape.MaterialsLength()):
                if meshShape.Materials(i) is None:
                    self.materials.append(None)
                else:
                    materialInfo_ = Titan.Model.MaterialInfo.MaterialInfoT.InitFromObj(meshShape.Materials(i))
                    self.materials.append(materialInfo_)
        self.res0 = meshShape.Res0()
        self.res1 = meshShape.Res1()
        self.res2 = meshShape.Res2()
        self.res3 = meshShape.Res3()
        if meshShape.ClipSphere() is not None:
            self.clipSphere = Titan.Model.Sphere.SphereT.InitFromObj(meshShape.ClipSphere())
        if not meshShape.InfluenceIsNone():
            self.influence = []
            for i in range(meshShape.InfluenceLength()):
                if meshShape.Influence(i) is None:
                    self.influence.append(None)
                else:
                    influence_ = Titan.Model.Influence.InfluenceT.InitFromObj(meshShape.Influence(i))
                    self.influence.append(influence_)
        if not meshShape.VisShapesIsNone():
            self.visShapes = []
            for i in range(meshShape.VisShapesLength()):
                if meshShape.VisShapes(i) is None:
                    self.visShapes.append(None)
                else:
                    visShape_ = Titan.Model.VisShape.VisShapeT.InitFromObj(meshShape.VisShapes(i))
                    self.visShapes.append(visShape_)
        self.meshName = meshShape.MeshName()
        self.unk13 = meshShape.Unk13()
        if not meshShape.MorphShapeIsNone():
            self.morphShape = []
            for i in range(meshShape.MorphShapeLength()):
                if meshShape.MorphShape(i) is None:
                    self.morphShape.append(None)
                else:
                    morphShape_ = Titan.Model.MorphShape.MorphShapeT.InitFromObj(meshShape.MorphShape(i))
                    self.morphShape.append(morphShape_)

    # MeshShapeT
    def Pack(self, builder):
        if self.meshShapeName is not None:
            meshShapeName = builder.CreateString(self.meshShapeName)
        if self.bounds is not None:
            bounds = self.bounds.Pack(builder)
        if self.attributes is not None:
            attributeslist = []
            for i in range(len(self.attributes)):
                attributeslist.append(self.attributes[i].Pack(builder))
            MeshShapeStartAttributesVector(builder, len(self.attributes))
            for i in reversed(range(len(self.attributes))):
                builder.PrependUOffsetTRelative(attributeslist[i])
            attributes = builder.EndVector()
        if self.materials is not None:
            materialslist = []
            for i in range(len(self.materials)):
                materialslist.append(self.materials[i].Pack(builder))
            MeshShapeStartMaterialsVector(builder, len(self.materials))
            for i in reversed(range(len(self.materials))):
                builder.PrependUOffsetTRelative(materialslist[i])
            materials = builder.EndVector()
        if self.influence is not None:
            influencelist = []
            for i in range(len(self.influence)):
                influencelist.append(self.influence[i].Pack(builder))
            MeshShapeStartInfluenceVector(builder, len(self.influence))
            for i in reversed(range(len(self.influence))):
                builder.PrependUOffsetTRelative(influencelist[i])
            influence = builder.EndVector()
        if self.visShapes is not None:
            visShapeslist = []
            for i in range(len(self.visShapes)):
                visShapeslist.append(self.visShapes[i].Pack(builder))
            MeshShapeStartVisShapesVector(builder, len(self.visShapes))
            for i in reversed(range(len(self.visShapes))):
                builder.PrependUOffsetTRelative(visShapeslist[i])
            visShapes = builder.EndVector()
        if self.meshName is not None:
            meshName = builder.CreateString(self.meshName)
        if self.morphShape is not None:
            morphShapelist = []
            for i in range(len(self.morphShape)):
                morphShapelist.append(self.morphShape[i].Pack(builder))
            MeshShapeStartMorphShapeVector(builder, len(self.morphShape))
            for i in reversed(range(len(self.morphShape))):
                builder.PrependUOffsetTRelative(morphShapelist[i])
            morphShape = builder.EndVector()
        MeshShapeStart(builder)
        if self.meshShapeName is not None:
            MeshShapeAddMeshShapeName(builder, meshShapeName)
        if self.bounds is not None:
            MeshShapeAddBounds(builder, bounds)
        MeshShapeAddPolygonType(builder, self.polygonType)
        if self.attributes is not None:
            MeshShapeAddAttributes(builder, attributes)
        if self.materials is not None:
            MeshShapeAddMaterials(builder, materials)
        MeshShapeAddRes0(builder, self.res0)
        MeshShapeAddRes1(builder, self.res1)
        MeshShapeAddRes2(builder, self.res2)
        MeshShapeAddRes3(builder, self.res3)
        if self.clipSphere is not None:
            clipSphere = self.clipSphere.Pack(builder)
            MeshShapeAddClipSphere(builder, clipSphere)
        if self.influence is not None:
            MeshShapeAddInfluence(builder, influence)
        if self.visShapes is not None:
            MeshShapeAddVisShapes(builder, visShapes)
        if self.meshName is not None:
            MeshShapeAddMeshName(builder, meshName)
        MeshShapeAddUnk13(builder, self.unk13)
        if self.morphShape is not None:
            MeshShapeAddMorphShape(builder, morphShape)
        meshShape = MeshShapeEnd(builder)
        return meshShape
